\chapter{Мультиплексоры соединений}
\begin{epigraphs}
\qitem{Если сразу успеха не добились, пытайтесь снова и снова. 
Затем оставьте эти попытки. Какой смысл глупо упорствовать?}{Уильям Клод Филдс}
\end{epigraphs}
\section{Введение}
Мультиплексоры соединений(программы для создания пула коннектов) позволяют уменьшить накладные расходы на базу данных, 
в случае, когда огромное количество физических соединений ведет к падению производительности PostgreSQL. 
Это особенно важно на Windows, когда система ограничивает большое количество соединений. 
Это также важно для веб-приложений, где количество соединений может быть очень большим.

Вот список программ, которые создают пулы соединений:
\begin{itemize}
\item PgBouncer
\item Pgpool
\end{itemize}

\section{PgBouncer}
Это мультиплексор соединений для PostgreSQL от компании Skype. Существуют три режима управления.
\begin{itemize}
\item \textbf{Session Pooling.}
Наиболее <<вежливый>> режим. При начале сессии клиенту выделяется соединение с сервером; 
оно приписано ему в течение всей сессии и возвращается в пул только после отсоединения клиента. 
\item \textbf{Transaction Pooling.} 
Клиент владеет соединением с бакендом только в течение транзакции. Когда PgBouncer замечает, 
что транзакция завершилась, он возвращает соединение назад в пул. 
\item \textbf{Statement Pooling.} 
Наиболее агрессивный режим. Соединение с бакендом возвращается назад в пул сразу после завершения 
запроса. Транзакции с несколькими запросами в этом режиме не разрешены, так как они гарантировано будут отменены.
Также не работают подготовленные выражения (prepared statements) в этом режиме.
\end{itemize}

К достоинствам PgBouncer относится:
\begin{itemize}
\item малое потребление памяти (менее 2 КБ на соединение);
\item отсутствие привязки к одному серверу баз данных;
\item реконфигурация настроек без рестарта.
\end{itemize}

Базовая утилита запускается так:
\begin{lstlisting}[label=lst:pgbouncer1,caption=PgBouncer]
pgbouncer [-d][-R][-v][-u user] <pgbouncer.ini>
\end{lstlisting}

Простой пример для конфига:
\begin{lstlisting}[label=lst:pgbouncer2,caption=PgBouncer]
[databases]
template1 = host=127.0.0.1 port=5432 dbname=template1
[pgbouncer]
listen_port = 6543
listen_addr = 127.0.0.1
auth_type = md5
auth_file = userlist.txt
logfile = pgbouncer.log
pidfile = pgbouncer.pid
admin_users = someuser
\end{lstlisting}

Нужно создать файл пользователей userlist.txt примерного содержания:''someuser'' ''same\_password\_as\_in\_server''

Админский доступ из консоли к базе данных pgbouncer:
\begin{lstlisting}[label=lst:pgbouncer3,caption=PgBouncer]
psql -h 127.0.0.1 -p 6543 pgbouncer
\end{lstlisting}

Здесь можно получить различную статистическую информацию с помощью команды SHOW.

\section{PgPool-II vs PgBouncer}

Все очень просто. PgBouncer намного лучше работает с пулами соединений, чем PgPool-II. Если вам не 
нужны остальные фичи, которыми владеет PgPool-II (ведь пулы коннектов это мелочи к его функционалу), 
то конечно лучше использовать PgBouncer. 
\begin{itemize}
\item PgBouncer потребляет меньше памяти, чем PgPool-II
\item у PgBouncer возможно настроить очередь соединений
\item в PgBouncer можно настраивать псевдо базы данных (на сервере они могут называтся по другому)
\end{itemize}

Хотя некоторые используют PgBouncer и PgPool-II совместно.