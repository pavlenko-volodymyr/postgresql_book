\section{Настройка сервера}
В этом разделе описаны рекомендуемые значения параметров, влияющих на производительность СУБД. Эти параметры 
обычно устанавливаются в конфигурационном файле postgresql.conf и влияют на все базы в текущей установке.


\subsection{Используемая память}
\subsubsection{Общий буфер сервера: shared\_buffers}
PostgreSQL не читает данные напрямую с диска и не пишет их сразу на диск. Данные загружаются в общий буфер сервера, 
находящийся в разделяемой памяти, серверные процессы читают и пишут блоки в этом буфере, а затем уже 
изменения сбрасываются на диск. 

Если процессу нужен доступ к таблице, то он сначала ищет нужные блоки в 
общем буфере. Если блоки присутствуют, то он может продолжать работу, если нет~--- делается системный вызов для 
их загрузки. Загружаться блоки могут как из файлового кэша ОС, так и с диска, и эта операция может оказаться весьма <<дорогой>>.

Если объём буфера недостаточен для хранения часто используемых рабочих данных, то они будут постоянно 
писаться и читаться из кэша ОС или с диска, что крайне отрицательно скажется на производительности.

В то же время не следует устанавливать это значение слишком большим:
это НЕ вся память, которая нужна для работы PostgreSQL, это только размер разделяемой между процессами PostgreSQL памяти, 
которая нужна для выполнения активных операций. Она должна занимать меньшую часть оперативной памяти вашего компьютера, так как 
PostgreSQL полагается на то, что операционная система кэширует файлы, и не 
старается дублировать эту работу. Кроме того, чем больше памяти будет отдано под буфер, тем 
меньше останется операционной системе и другим приложениям, что может привести к своппингу.

К сожалению, чтобы знать точное число shared\_buffers, нужно 
учесть количество оперативной памяти компьютера, размер базы данных, число соединений и сложность запросов, так что лучше 
воспользуемся несколькими простыми правилами настройки.

На выделенных серверах полезным объемом будет значение от 8 МБ до 2 ГБ. 
Объем может быть выше, если у вас большие активные порции базы данных, сложные запросы, большое число 
одновременных соединений, длительные транзакции, вам доступен большой объем оперативной памяти или большее количество 
процессоров. И, конечно же, не забываем об остальных приложениях. Выделив слишком много памяти для базы данных, 
мы можем получить ухудшение производительности. 
В качестве начальных значений можете попробовать следующие:
\begin{itemize}
\item Начните с 4 МБ (512) для рабочей станции
\item Средний объём данных и 256--512 МБ доступной памяти: 16--32 МБ (2048--4096)
\item Большой объём данных и 1--4 ГБ доступной памяти: 64--256 МБ (8192--32768)
\end{itemize}

Для тонкой настройки параметра установите для него большое значение и потестируйте базу при обычной нагрузке. 
Проверяйте использование разделяемой памяти при помощи ipcs или других утилит(например, free или vmstat). 
Рекомендуемое значение параметра 
будет примерно в 1,2~--2 раза больше, чем максимум использованной памяти. Обратите внимание, что память под буфер 
выделятся при запуске сервера, и её объём при работе не изменяется. Учтите также, что настройки ядра операционной 
системы могут не дать вам выделить большой объём памяти. В руководстве администратора PostgreSQL описано, как 
можно изменить эти настройки: \\http://developer.postgresql.org/docs/postgres/kernel-resources.html

Вот несколько примеров, полученных на личном опыте и при тестировании:
\begin{itemize}
\item Laptop, Celeron processor, 384 МБ RAM, база данных 25 МБ: 12 МБ
\item Athlon server, 1 ГБ RAM, база данных поддержки принятия решений 10 ГБ: 200 МБ
\item Quad PIII server, 4 ГБ RAM, 40 ГБ, 150 соединений, <<тяжелые>> транзакции: 1 ГБ
\item Quad Xeon server, 8 ГБ RAM, 200 ГБ, 300 соединений, <<тяжелые>> транзакции: 2 ГБ
\end{itemize}

\subsubsection{Память для сортировки результата запроса: work\_mem}
Ранее известное как sort\_mem, было переименовано, так как сейчас определяет максимальное количество оперативной памяти, 
которое может выделить одна операция сортировки, агрегации и др. Это не разделяемая память, work\_mem выделяется отдельно 
на каждую операцию (от одного до нескольких раз за один запрос). Разумное значение параметра определяется следующим образом: 
количество доступной оперативной памяти (после того, как из общего объема вычли память, требуемую для других приложений, и 
shared\_buffers) делится на максимальное число одновременных запросов умноженное на среднее число операций в запросе, которые 
требуют памяти.

Если объём памяти недостаточен для сортироки некоторого результата, то серверный процесс будет использовать 
временные файлы. Если же объём памяти слишком велик, то это может привести к своппингу.

Объём памяти задаётся параметром work\_mem в файле postgresql.conf. Единица измерения параметра~--- 1 кБ. 
Значение по умолчанию~--- 1024. В качестве начального значения для параметра можете взять 2--4\% доступной памяти.
Для веб-приложений обычно устанавливают низкие значения work\_mem, так как запросов обычно много, но они простые, обычно хватает 
от 512 до 2048 КБ. С другой стороны, приложения для поддержки принятия решений с сотнями строк в каждом запросе и десятками 
миллионов столбцов  в таблицах фактов часто требуют work\_mem порядка 500 МБ. Для баз данных, которые используются и так, и так, 
этот параметр можно устанавливать для каждого запроса индивидуально, используя настройки сессии. Например, 
при памяти 1--4 ГБ рекомендуется устанавливать 32--128 MB. 

\subsubsection{Память для работы команды VACUUM: maintenance\_work\_mem}
Предыдущее название в PostgreSQL 7.x vacuum\_mem. Этот параметр задаёт объём памяти, используемый командами 
VACUUM, ANALYZE, CREATE INDEX, и добавления внешних ключей. 
Чтобы операции выполнялись максимально быстро, нужно устанавливать этот параметр тем выше, чем больше размер таблиц в 
вашей базе данных. Неплохо бы устанавливать его значение от 50 до 75\% размера вашей самой большой таблицы или индекса или, 
если точно определить невозможно, от 32 до 256 МБ. Следует устанавливать большее значение, чем для work\_mem. 
Слишком большие значения приведут к использованию свопа. Например, при памяти 1--4 ГБ рекомендуется устанавливать 128--512 MB.

\subsubsection{Free Space Map: как избавиться от VACUUM FULL}
Особенностями версионных движков БД (к которым относится и используемый в PostgreSQL) является следующее:
\begin{itemize}
\item Транзакции, изменяющие данные в таблице, не блокируют транзакции, читающие из неё данные, и наоборот (это хорошо);
\item При изменении данных в таблице (командами UPDATE или DELETE) накапливается мусор\footnote{под которым понимаются 
старые версии изменённых/удалённых записей} (а это плохо).
\end{itemize}
В каждой СУБД сборка мусора реализована особым образом, в PostgreSQL для этой цели применяется команда VACUUM (описана в пункте 3.1.1).

До версии 7.2 команда VACUUM полностью блокировала таблицу. Начиная с версии 7.2, команда VACUUM накладывает более слабую 
блокировку, позволяющую параллельно выполнять команды SELECT, INSERT, UPDATE и DELETE над обрабатываемой таблицей. 
Старый вариант команды называется теперь VACUUM FULL.

Новый вариант команды не пытается удалить все старые версии записей и, соответственно, уменьшить размер файла, содержащего таблицу, 
а лишь помечает занимаемое ими место как свободное. Для информации о свободном месте есть следующие настройки:
\begin{itemize}
\item \textbf{max\_fsm\_relations}

Максимальное количество таблиц, для которых будет отслеживаться свободное место в общей карте свободного пространства. 
Эти данные собираются VACUUM. Параметр max\_fsm\_relations должен быть не меньше общего количества таблиц во всех 
базах данной установки (лучше с запасом). 

\item \textbf{max\_fsm\_pages}

Данный параметр определяет размер реестра, в котором хранится информация о частично освобождённых страницах данных, 
готовых к заполнению новыми данными. Значение этого параметра нужно установить чуть больше, чем полное число страниц, 
которые могут быть затронуты 
операциями обновления или удаления между выполнением VACUUM. Чтобы определить это число, можно запустить VACUUM VERBOSE ANALYZE 
и выяснить общее число страниц, используемых базой данных. max\_fsm\_pages обычно требует немного памяти, так что на этом 
параметре лучше не экономить. 
\end{itemize}

Если эти параметры установленны верно и информация обо всех изменениях помещается в FSM, 
то команды VACUUM будет достаточно для сборки мусора, если нет~-- понадобится
VACUUM FULL, во время работы которой нормальное использование БД сильно затруднено.

\textbf{ВНИМАНИЕ!} Начиная с 8.4 версии fsm параметры были убраны, поскольку Free Space Map сохраняется на жесткий диск, а не в память.

\subsubsection{Прочие настройки}
\begin{itemize}
\item \textbf{temp\_buffers}

Буфер под временные объекты, в основном для временных таблиц.
Можно установить порядка 16 МБ.

\item \textbf{max\_prepared\_transactions}

Количество одновременно подготавливаемых транзакций (PREPARE TRANSACTION).
Можно оставить по дефолту~--- 5.

\item \textbf{vacuum\_cost\_delay} 

Если у вас большие таблицы, и производится много одновременных операций записи, 
вам может пригодиться функция, которая уменьшает затраты на I/O для VACUUM, растягиваяя его по времени. 
Чтобы включить эту функциональность, нужно поднять 
значение vacuum\_cost\_delay выше 0. Используйте разумную задержку от 50 до 200 мс. Для более тонкой настройки повышайте 
vacuum\_cost\_page\_hit и понижайте vacuum\_cost\_page\_limit. Это ослабит влияние VACUUM, увеличив время его выполнения. 
В тестах с параллельными транзакциями Ян Вик (Jan Wieck) получил, что при значениях delay~--- 200, page\_hit~--- 6 и предел~--- 
100 вляние VACUUM уменьшилось более чем на 80\%, но его длительность увеличилась втрое. 

\item \textbf{max\_stack\_depth}

Специальный стек для сервера, в идеале он должен совпадать с размером стека, выставленном в ядре ОС. 
Установка большего значения, чем в ядре, может привести к ошибкам.
Рекомендуется устанавливать 2--4 MB.

\item \textbf{max\_files\_per\_process}

Максимальное количество файлов, открываемых процессом и его подпроцессами в один момент времени.
Уменьшите данный параметр, если в процессе работы наблюдается сообщение <<Too many open files>>.
\end{itemize}


\subsection{Журнал транзакций и контрольные точки}
Журнал транзакций PostgreSQL работает следующим образом: все изменения в файлах данных (в которых находятся таблицы и 
индексы) производятся только после того, как они были занесены в журнал транзакций, при этом записи в журнале должны 
быть гарантированно записаны на диск.

В этом случае нет необходимости сбрасывать на диск изменения данных при каждом успешном завершении транзакции: 
в случае сбоя БД может быть восстановлена по записям в журнале. Таким образом, данные из буферов сбрасываются на диск 
при проходе контрольной точки: либо при заполнении нескольких (параметр checkpoint\_segments, по умолчанию 3) сегментов
журнала транзакций, либо через определённый интервал времени (параметр checkpoint\_timeout, измеряется в секундах, по умолчанию 300).

Изменение этих параметров прямо не повлияет на скорость чтения, но может принести большую пользу, если данные в базе активно изменяются.

\subsubsection{Уменьшение количества контрольных точек: checkpoint\_segments}
Если в базу заносятся большие объёмы данных, то контрольные точки могут происходить слишком часто\footnote{<<слишком часто>> 
можно определить как <<чаще раза в минуту>>. Вы также можете задать параметр checkpoint\_warning (в секундах): 
в журнал сервера будут писаться предупреждения, если контрольные точки происходят чаще заданного.}. 
При этом производительность упадёт из-за постоянного сбрасывания на диск данных из буфера.

Для увеличения интервала между контрольными точками нужно увеличить количество сегментов журнала транзакций (checkpoint\_segments). 
Данный параметр определяет количество сегментов (каждый по 16 МБ) лога транзакций между контрольными точками. 
Этот параметр не имеет особого значения для базы данных, предназначенной преимущественно для чтения, но для баз данных со 
множеством транзакций увеличение этого параметра может оказаться жизненно необходимым. В зависимости от объема данных 
установите этот параметр в диапазоне от 12 до 256 сегментов и, если в логе появляются предупреждения (warning) о том, что 
контрольные точки происходят слишком часто, постепенно увеличивайте его. Место, требуемое на диске, вычисляется по формуле 
(checkpoint\_segments * 2 + 1) * 16 МБ, так что убедитесь, что у вас достаточно свободного места. Например, если вы выставите 
значение 32, вам потребуется больше 1 ГБ дискового пространства.

Следует также отметить, что чем больше интервал между контрольными точками, тем дольше будут восстанавливаться данные по 
журналу транзакций после сбоя.

\subsubsection{fsync и стоит ли его трогать}
Наиболее радикальное из возможных решений~--- выставить значение <<off>> параметру fsync. При этом записи в журнале транзакций не 
будут принудительно сбрасываться на диск, что даст большой прирост скорости записи. Учтите: вы жертвуете надёжностью, в случае 
сбоя целостность базы будет нарушена, и её придётся восстанавливать из резервной копии!

Использовать этот параметр рекомендуется лишь в том случае, если вы всецело доверяете своему <<железу>> и своему источнику 
бесперебойного питания. Ну или если данные в базе не представляют для вас особой ценности.

\subsubsection{Прочие настройки}
\begin{itemize}
\item 
\textbf{commit\_delay} (в микросекундах, 0 по умолчанию) и \textbf{commit\_sib\-lings} (5 по умолчанию) 

определяют задержку между попаданием записи в буфер журнала транзакций и сбросом её на диск. 
Если при успешном завершении транзакции активно не менее commit\_siblings транзакций, то запись будет задержана на время 
commit\_delay. Если за это время завершится другая транзакция, то их изменения будут сброшены на диск вместе, при помощи 
одного системного вызова. Эти параметры позволят ускорить работу, если параллельно выполняется много <<мелких>> транзакций.

\item \textbf{wal\_sync\_method}

Метод, который используется для принудительной записи данных на диск.
Если fsync=off, то этот параметр не используется.
Возможные значения:
\begin{itemize}
\item open\_datasync~--- запись данных методом open() с параметром O\_DSYNC
\item fdatasync~--- вызов метода fdatasync() после каждого commit
\item fsync\_writethrough~--- вызов fsync() после каждого commit, игнорируя параллельные процессы
\item fsync~--- вызов fsync() после каждого commit
\item open\_sync~--- запись данных методом open() с параметром O\_SYNC
\end{itemize}

Не все эти методы доступны на разных ОС. По умолчанию устанавливается первый, который доступен для системы.

\item \textbf{full\_page\_writes}

Установите данный параметр в off, если fsync=off. Иначе, когда этот параметр on, PostgreSQL записывает содержимое 
каждой записи в журнал транзакций при первой модификации таблицы. Это необходимо, поскольку 
данные могут записаться лишь частично, если в ходе процесса <<упала>> ОС. Это приведет к тому, что на диске окажутся 
новые данные смешанные со старыми. Строкового уровня записи в журнал транзакций может быть недостаточно, чтобы полностью 
восстановить данные после <<падения>>. full\_page\_writes гарантирует корректное восстановление, ценой увелечения записываемых 
данных в журнал транзакций (Единственный способ снижения объема записи в журнал транзакций заключается в 
увеличении checkpoint\_interval).

\item \textbf{wal\_buffers}

Количество памяти используемое в SHARED MEMORY для ведения транзакционных логов\footnote{буфер находится в 
разделяемой памяти и является общим для всех процессов}.
Стоит увеличить буфер до 256--512 кБ, что позволит лучше работать с большими транзакциями.
Например, при доступной памяти 1--4 ГБ рекомендуется устанавливать 256--1024 КБ.

\end{itemize}


\subsection{Планировщик запросов}
Следующие настройки помогают планировщику запросов правильно оценивать стоимости различных 
операций и выбирать оптимальный план выполнения запроса. Существуют 3 настройки планировщика, 
на которые стоит обратить внимание:
\begin{itemize}
\item \textbf{default\_statistics\_target} 

Этот параметр задаёт объём статистики, собираемой командой ANALYZE (см. пункт 3.1.2). 
Увеличение параметра заставит эту команду работать дольше, но может позволить оптимизатору строить более быстрые планы, 
используя полученные дополнительные данные. Объём статистики для конкретного поля может быть задан командой 
ALTER TABLE \dots SET STATISTICS.

\item \textbf{effective\_cache\_size}

Этот параметр сообщает PostgreSQL примерный объём файлового кэша операционной системы, оптимизатор использует эту оценку для 
построения плана запроса\footnote{Указывает планировщику на размер самого большого объекта в базе данных, который 
теоретически может быть закеширован}.

Пусть в вашем компьютере 1,5 ГБ памяти, параметр shared\_buffers установлен в 32 МБ, а параметр effective\_cache\_size в 800 МБ. 
Если запросу нужно 700 МБ данных, то PostgreSQL оценит, что все нужные данные уже есть в памяти и выберет более агрессивный план с 
использованием индексов и merge joins. Но если effective\_cache\_size будет всего 200 МБ, то оптимизатор вполне может выбрать более 
эффективный для дисковой системы план, включающий полный просмотр таблицы.

На выделенном сервере имеет смысл выставлять effective\_cache\_size в 2/3 от всей оперативной памяти; на сервере с 
другими приложениями сначала нужно вычесть из всего объема RAM размер дискового кэша ОС и память, 
занятую остальными процессами.

\item \textbf{random\_page\_cost} 

Переменная, указывающая на условную стоимость индексного доступа к страницам данных. На серверах с быстрыми дисковыми 
массивами имеет смысл уменьшать изначальную настройку до 3.0, 2.5 или даже до 2.0. Если же активная часть вашей базы данных 
намного больше размеров оперативной памяти, попробуйте поднять значение параметра. Можно подойти к выбору оптимального значения 
и со стороны производительности запросов. Если планировщик запросов чаще, чем необходимо, предпочитает последовательные просмотры 
(sequential scans) просмотрам с использованием индекса (index scans), понижайте значение. И наоборот, если планировщик выбирает 
просмотр по медленному индексу, когда не должен этого делать, настройку имеет смысл увеличить. После изменения тщательно тестируйте 
результаты на максимально широком наборе запросов. Никогда не опускайте значение random\_page\_cost ниже 2.0; если вам кажется, 
что random\_page\_cost нужно еще понижать, разумнее в этом случае менять настройки статистики планировщика. 
\end{itemize}

\subsection{Сбор статистики}
У PostgreSQL также есть специальная подсистема~--- сборщик статистики,~--- которая в реальном времени собирает данные об 
активности сервера. Поскольку сбор статистики создает дополнительные накладные расходы на базу данных, то система может быть настроена 
как на сбор, так и не сбор статистики вообще.
Эта система контролируется следующими параметрами, принимающими значения true/false:
\begin{itemize}
\item \textbf{track\_counts} включать ли сбор статистики. По умолчанию включён, поскольку autovacuum демону требуется сбор статистики. 
Отключайте, только если статистика вас совершенно не интересует (как и autovacuum).
\item \textbf{track\_functions} отслеживание использования определенных пользователем функций.
\item \textbf{track\_activities} передавать ли сборщику статистики информацию о текущей выполняемой команде и времени 
начала её выполнения. По умолчанию эта возможность включена. Следует отметить, что эта информация будет доступна только 
привилегированным пользователям и пользователям, от лица которых запущены команды, так что проблем с безопасностью быть не должно.
\end{itemize}

Данные, полученные сборщиком статистики, доступны через специальные системные представления. При установках по умолчанию собирается 
очень мало информации, рекомендуется включить все возможности: дополнительная нагрузка будет невелика, в то время как полученные 
данные позволят оптимизировать использование индексов (а также помогут оптимальной работе autovacuum демону).